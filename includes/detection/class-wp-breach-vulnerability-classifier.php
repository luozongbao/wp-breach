<?php

/**
 * The vulnerability classification and detection engine.
 *
 * This class handles the main vulnerability detection logic, coordinating
 * between different detectors and providing severity assessment.
 *
 * @link       https://wpbreach.com
 * @since      1.0.0
 *
 * @package    WP_Breach
 * @subpackage WP_Breach/includes/detection
 */

/**
 * The vulnerability classifier class.
 *
 * This class coordinates vulnerability detection across multiple detectors,
 * manages severity assessment, and provides unified vulnerability classification.
 *
 * @since      1.0.0
 * @package    WP_Breach
 * @subpackage WP_Breach/includes/detection
 * @author     WP Breach Team
 */
class WP_Breach_Vulnerability_Classifier {

    /**
     * The current version of the classifier.
     *
     * @since    1.0.0
     * @access   protected
     * @var      string    $version    The current version of the classifier.
     */
    protected $version;

    /**
     * Array of loaded detectors.
     *
     * @since    1.0.0
     * @access   protected
     * @var      array    $detectors    Array of detector instances.
     */
    protected $detectors;

    /**
     * Pattern detector instance.
     *
     * @since    1.0.0
     * @access   protected
     * @var      WP_Breach_Pattern_Detector    $pattern_detector    Pattern detector instance.
     */
    protected $pattern_detector;

    /**
     * Severity calculator instance.
     *
     * @since    1.0.0
     * @access   protected
     * @var      WP_Breach_Severity_Calculator    $severity_calculator    Severity calculator instance.
     */
    protected $severity_calculator;

    /**
     * Vulnerability database instance.
     *
     * @since    1.0.0
     * @access   protected
     * @var      WP_Breach_Vuln_Database    $vuln_database    Vulnerability database instance.
     */
    protected $vuln_database;

    /**
     * Cache for detection results.
     *
     * @since    1.0.0
     * @access   protected
     * @var      array    $detection_cache    Cache for detection results.
     */
    protected $detection_cache;

    /**
     * Configuration options.
     *
     * @since    1.0.0
     * @access   protected
     * @var      array    $config    Configuration options.
     */
    protected $config;

    /**
     * Initialize the classifier.
     *
     * @since    1.0.0
     * @param    string    $version    The version of the classifier.
     */
    public function __construct($version = '1.0.0') {
        $this->version = $version;
        $this->detectors = array();
        $this->detection_cache = array();
        $this->load_config();
        $this->init_components();
        $this->load_detectors();
    }

    /**
     * Load configuration options.
     *
     * @since    1.0.0
     */
    private function load_config() {
        $defaults = array(
            'enable_external_apis' => true,
            'cache_external_results' => true,
            'cache_duration' => 3600, // 1 hour
            'max_file_size' => 5242880, // 5MB
            'enable_deep_analysis' => true,
            'false_positive_threshold' => 0.1,
            'min_confidence_level' => 0.7,
            'enable_machine_learning' => false,
            'api_rate_limit' => 100, // requests per hour
        );

        $stored_config = get_option('wp_breach_classifier_config', array());
        $this->config = wp_parse_args($stored_config, $defaults);
    }

    /**
     * Initialize core components.
     *
     * @since    1.0.0
     */
    private function init_components() {
        // Initialize pattern detector
        require_once plugin_dir_path(dirname(__FILE__)) . 'detection/class-wp-breach-pattern-detector.php';
        $this->pattern_detector = new WP_Breach_Pattern_Detector();

        // Initialize severity calculator
        require_once plugin_dir_path(dirname(__FILE__)) . 'detection/class-wp-breach-severity-calculator.php';
        $this->severity_calculator = new WP_Breach_Severity_Calculator();

        // Initialize vulnerability database
        require_once plugin_dir_path(dirname(__FILE__)) . 'detection/class-wp-breach-vuln-database.php';
        $this->vuln_database = new WP_Breach_Vuln_Database();
    }

    /**
     * Load all vulnerability detectors.
     *
     * @since    1.0.0
     */
    private function load_detectors() {
        $detector_files = array(
            'sql-injection' => 'class-wp-breach-sql-injection-detector.php',
            'xss' => 'class-wp-breach-xss-detector.php',
            'csrf' => 'class-wp-breach-csrf-detector.php',
            'file-inclusion' => 'class-wp-breach-file-inclusion-detector.php',
            'auth-bypass' => 'class-wp-breach-auth-bypass-detector.php',
        );

        foreach ($detector_files as $type => $file) {
            $file_path = plugin_dir_path(dirname(__FILE__)) . 'detection/detectors/' . $file;
            if (file_exists($file_path)) {
                require_once $file_path;
                $class_name = $this->get_detector_class_name($type);
                if (class_exists($class_name)) {
                    $this->detectors[$type] = new $class_name();
                }
            }
        }
    }

    /**
     * Get detector class name from type.
     *
     * @since    1.0.0
     * @param    string    $type    The detector type.
     * @return   string             The class name.
     */
    private function get_detector_class_name($type) {
        $words = explode('-', $type);
        $words = array_map('ucfirst', $words);
        return 'WP_Breach_' . implode('_', $words) . '_Detector';
    }

    /**
     * Classify vulnerabilities in a file.
     *
     * @since    1.0.0
     * @param    string    $file_path       The file path to analyze.
     * @param    array     $options         Analysis options.
     * @return   array                      Array of detected vulnerabilities.
     */
    public function classify_file($file_path, $options = array()) {
        // Check if file exists and is readable
        if (!file_exists($file_path) || !is_readable($file_path)) {
            return array(
                'success' => false,
                'error' => 'File not found or not readable: ' . $file_path,
                'vulnerabilities' => array()
            );
        }

        // Check file size
        if (filesize($file_path) > $this->config['max_file_size']) {
            return array(
        $file_size = filesize($file_path);
        if ($file_size === false) {
            return array(
                'success' => false,
                'error' => 'Unable to determine file size: ' . $file_path,
                'vulnerabilities' => array()
            );
        }
        if ($file_size > $this->config['max_file_size']) {
            return array(
                'success' => false,
                'error' => 'File too large for analysis: ' . $file_path,
                'vulnerabilities' => array()
            );
        }

        // Generate cache key
        $cache_key = md5($file_path . filemtime($file_path) . serialize($options));
        
        // Check cache
        if (isset($this->detection_cache[$cache_key])) {
            return $this->detection_cache[$cache_key];
        }

        // Read file content
        $content = file_get_contents($file_path);
        if ($content === false) {
            return array(
                'success' => false,
                'error' => 'Unable to read file content: ' . $file_path,
                'vulnerabilities' => array()
            );
        }

        $vulnerabilities = array();
        $file_info = $this->analyze_file_info($file_path, $content);

        // Run pattern-based detection
        $pattern_results = $this->pattern_detector->detect_patterns($content, $file_path);
        if (!empty($pattern_results)) {
            $vulnerabilities = array_merge($vulnerabilities, $pattern_results);
        }

        // Run specific detector analysis
        foreach ($this->detectors as $type => $detector) {
            if (method_exists($detector, 'detect')) {
                $detector_results = $detector->detect($content, $file_path, $file_info);
                if (!empty($detector_results)) {
                    $vulnerabilities = array_merge($vulnerabilities, $detector_results);
                }
            }
        }

        // Check external vulnerability databases
        if ($this->config['enable_external_apis']) {
            $external_results = $this->check_external_databases($file_info);
            if (!empty($external_results)) {
                $vulnerabilities = array_merge($vulnerabilities, $external_results);
            }
        }

        // Process and enhance vulnerabilities
        $processed_vulnerabilities = $this->process_vulnerabilities($vulnerabilities, $file_info);

        // Filter false positives
        $filtered_vulnerabilities = $this->filter_false_positives($processed_vulnerabilities);

        $result = array(
            'success' => true,
            'file_path' => $file_path,
            'file_info' => $file_info,
            'vulnerabilities' => $filtered_vulnerabilities,
            'scan_time' => current_time('mysql'),
            'total_vulnerabilities' => count($filtered_vulnerabilities),
            'severity_breakdown' => $this->get_severity_breakdown($filtered_vulnerabilities)
        );

        // Cache result
        $this->detection_cache[$cache_key] = $result;

        return $result;
    }

    /**
     * Classify vulnerabilities in multiple files.
     *
     * @since    1.0.0
     * @param    array     $file_paths      Array of file paths to analyze.
     * @param    array     $options         Analysis options.
     * @return   array                      Array of detection results.
     */
    public function classify_files($file_paths, $options = array()) {
        $results = array();
        $total_vulnerabilities = 0;
        $start_time = microtime(true);

        foreach ($file_paths as $file_path) {
            $result = $this->classify_file($file_path, $options);
            $results[] = $result;
            
            if ($result['success']) {
                $total_vulnerabilities += $result['total_vulnerabilities'];
            }
        }

        $end_time = microtime(true);
        $scan_duration = $end_time - $start_time;

        return array(
            'success' => true,
            'results' => $results,
            'summary' => array(
                'total_files' => count($file_paths),
                'total_vulnerabilities' => $total_vulnerabilities,
                'scan_duration' => $scan_duration,
                'files_per_second' => count($file_paths) / $scan_duration,
                'scan_time' => current_time('mysql')
            )
        );
    }

    /**
     * Classify vulnerabilities in a plugin.
     *
     * @since    1.0.0
     * @param    string    $plugin_slug     The plugin slug to analyze.
     * @param    array     $options         Analysis options.
     * @return   array                      Plugin analysis result.
     */
    public function classify_plugin($plugin_slug, $options = array()) {
        $plugin_path = WP_PLUGIN_DIR . '/' . $plugin_slug;
        
        if (!is_dir($plugin_path)) {
            return array(
                'success' => false,
                'error' => 'Plugin directory not found: ' . $plugin_slug,
                'vulnerabilities' => array()
            );
        }

        // Get plugin files
        $files = $this->get_plugin_files($plugin_path);
        
        // Get plugin information
        $plugin_info = $this->get_plugin_info($plugin_slug);
        
        // Analyze files
        $results = $this->classify_files($files, $options);
        
        // Check plugin-specific vulnerabilities
        $plugin_vulns = $this->check_plugin_vulnerabilities($plugin_info);
        
        return array(
            'success' => true,
            'plugin_slug' => $plugin_slug,
            'plugin_info' => $plugin_info,
            'file_results' => $results,
            'plugin_vulnerabilities' => $plugin_vulns,
            'total_vulnerabilities' => $results['summary']['total_vulnerabilities'] + count($plugin_vulns)
        );
    }

    /**
     * Analyze file information.
     *
     * @since    1.0.0
     * @param    string    $file_path       The file path.
     * @param    string    $content         The file content.
     * @return   array                      File information.
     */
    private function analyze_file_info($file_path, $content) {
        $info = array(
            'path' => $file_path,
            'name' => basename($file_path),
            'extension' => pathinfo($file_path, PATHINFO_EXTENSION),
            'size' => strlen($content),
            'lines' => substr_count($content, "\n") + 1,
            'type' => $this->determine_file_type($file_path, $content),
            'is_wordpress_core' => $this->is_wordpress_core_file($file_path),
            'is_plugin' => $this->is_plugin_file($file_path),
            'is_theme' => $this->is_theme_file($file_path),
            'functions_count' => substr_count($content, 'function '),
            'class_count' => substr_count($content, 'class '),
            'sql_queries' => substr_count(strtolower($content), 'select ') + substr_count(strtolower($content), 'insert ') + substr_count(strtolower($content), 'update ') + substr_count(strtolower($content), 'delete '),
            'has_user_input' => $this->has_user_input_handling($content),
            'has_file_operations' => $this->has_file_operations($content),
            'has_network_calls' => $this->has_network_calls($content)
        );

        return $info;
    }

    /**
     * Determine file type.
     *
     * @since    1.0.0
     * @param    string    $file_path       The file path.
     * @param    string    $content         The file content.
     * @return   string                     The file type.
     */
    private function determine_file_type($file_path, $content) {
        $extension = pathinfo($file_path, PATHINFO_EXTENSION);
        
        switch ($extension) {
            case 'php':
                if (strpos($content, '<?php') === 0) {
                    return 'php';
                }
                break;
            case 'js':
                return 'javascript';
            case 'css':
                return 'css';
            case 'html':
            case 'htm':
                return 'html';
            case 'sql':
                return 'sql';
        }
        
        return 'unknown';
    }

    /**
     * Check if file is WordPress core file.
     *
     * @since    1.0.0
     * @param    string    $file_path       The file path.
     * @return   bool                       True if core file.
     */
    private function is_wordpress_core_file($file_path) {
        $wp_root = ABSPATH;
        $relative_path = str_replace($wp_root, '', $file_path);
        
        // Check if file is in wp-admin, wp-includes, or root level core files
        return (
            strpos($relative_path, 'wp-admin/') === 0 ||
            strpos($relative_path, 'wp-includes/') === 0 ||
            in_array(basename($file_path), array('wp-config.php', 'wp-load.php', 'wp-blog-header.php'))
        );
    }

    /**
     * Check if file is plugin file.
     *
     * @since    1.0.0
     * @param    string    $file_path       The file path.
     * @return   bool                       True if plugin file.
     */
    private function is_plugin_file($file_path) {
        return strpos($file_path, WP_PLUGIN_DIR) === 0;
    }

    /**
     * Check if file is theme file.
     *
     * @since    1.0.0
     * @param    string    $file_path       The file path.
     * @return   bool                       True if theme file.
     */
    private function is_theme_file($file_path) {
        return strpos($file_path, get_theme_root()) === 0;
    }

    /**
     * Check if content has user input handling.
     *
     * @since    1.0.0
     * @param    string    $content         The file content.
     * @return   bool                       True if has user input.
     */
    private function has_user_input_handling($content) {
        $input_patterns = array(
            '$_GET', '$_POST', '$_REQUEST', '$_COOKIE', '$_SERVER',
            'get_option', 'get_user_meta', 'get_post_meta'
        );
        
        foreach ($input_patterns as $pattern) {
            if (strpos($content, $pattern) !== false) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Check if content has file operations.
     *
     * @since    1.0.0
     * @param    string    $content         The file content.
     * @return   bool                       True if has file operations.
     */
    private function has_file_operations($content) {
        $file_patterns = array(
            'file_get_contents', 'file_put_contents', 'fopen', 'fwrite',
            'include', 'require', 'include_once', 'require_once',
            'file_exists', 'is_readable', 'is_writable'
        );
        
        foreach ($file_patterns as $pattern) {
            if (strpos($content, $pattern) !== false) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Check if content has network calls.
     *
     * @since    1.0.0
     * @param    string    $content         The file content.
     * @return   bool                       True if has network calls.
     */
    private function has_network_calls($content) {
        $network_patterns = array(
            'wp_remote_get', 'wp_remote_post', 'curl_init', 'file_get_contents',
            'fsockopen', 'stream_context_create'
        );
        
        foreach ($network_patterns as $pattern) {
            if (strpos($content, $pattern) !== false) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Process and enhance detected vulnerabilities.
     *
     * @since    1.0.0
     * @param    array     $vulnerabilities Array of detected vulnerabilities.
     * @param    array     $file_info       File information.
     * @return   array                      Processed vulnerabilities.
     */
    private function process_vulnerabilities($vulnerabilities, $file_info) {
        $processed = array();
        
        foreach ($vulnerabilities as $vuln) {
            // Calculate severity
            $severity_data = $this->severity_calculator->calculate_severity($vuln, $file_info);
            $vuln['severity'] = $severity_data['severity'];
            $vuln['risk_score'] = $severity_data['risk_score'];
            $vuln['confidence'] = isset($vuln['confidence']) ? $vuln['confidence'] : 0.8;
            
            // Add context information
            $vuln['file_info'] = $file_info;
            $vuln['detection_time'] = current_time('mysql');
            $vuln['detector_version'] = $this->version;
            
            // Generate unique ID
            $vuln['id'] = md5($file_info['path'] . $vuln['type'] . $vuln['line'] . $vuln['description']);
            
            $processed[] = $vuln;
        }
        
        return $processed;
    }

    /**
     * Filter false positives from vulnerabilities.
     *
     * @since    1.0.0
     * @param    array     $vulnerabilities Array of vulnerabilities.
     * @return   array                      Filtered vulnerabilities.
     */
    private function filter_false_positives($vulnerabilities) {
        $filtered = array();
        
        foreach ($vulnerabilities as $vuln) {
            // Skip if confidence is below threshold
            if ($vuln['confidence'] < $this->config['min_confidence_level']) {
                continue;
            }
            
            // Apply false positive filters
            if ($this->is_likely_false_positive($vuln)) {
                continue;
            }
            
            $filtered[] = $vuln;
        }
        
        return $filtered;
    }

    /**
     * Check if vulnerability is likely a false positive.
     *
     * @since    1.0.0
     * @param    array     $vuln            Vulnerability data.
     * @return   bool                       True if likely false positive.
     */
    private function is_likely_false_positive($vuln) {
        // Check for common false positive patterns
        $false_positive_patterns = array(
            // Comments containing vulnerability keywords
            'in_comment' => (isset($vuln['context']) && preg_match('/\/\*.*?\*\/|\/\/.*$/m', $vuln['context'])),
            
            // Test files
            'test_file' => (strpos($vuln['file_info']['path'], '/test') !== false || 
                           strpos($vuln['file_info']['path'], '/tests') !== false),
            
            // Documentation files
            'doc_file' => (in_array($vuln['file_info']['extension'], array('md', 'txt', 'rst'))),
            
            // Minified files
            'minified' => (strpos($vuln['file_info']['name'], '.min.') !== false)
        );
        
        foreach ($false_positive_patterns as $pattern => $is_match) {
            if ($is_match) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Get severity breakdown for vulnerabilities.
     *
     * @since    1.0.0
     * @param    array     $vulnerabilities Array of vulnerabilities.
     * @return   array                      Severity breakdown.
     */
    private function get_severity_breakdown($vulnerabilities) {
        $breakdown = array(
            'critical' => 0,
            'high' => 0,
            'medium' => 0,
            'low' => 0,
            'info' => 0
        );
        
        foreach ($vulnerabilities as $vuln) {
            $severity = isset($vuln['severity']) ? strtolower($vuln['severity']) : 'low';
            if (isset($breakdown[$severity])) {
                $breakdown[$severity]++;
            }
        }
        
        return $breakdown;
    }

    /**
     * Check external vulnerability databases.
     *
     * @since    1.0.0
     * @param    array     $file_info       File information.
     * @return   array                      External vulnerabilities found.
     */
    private function check_external_databases($file_info) {
        $external_vulns = array();
        
        if ($this->config['enable_external_apis']) {
            $external_vulns = $this->vuln_database->check_external_vulnerabilities($file_info);
        }
        
        return $external_vulns;
    }

    /**
     * Get plugin files for analysis.
     *
     * @since    1.0.0
     * @param    string    $plugin_path     Plugin directory path.
     * @return   array                      Array of file paths.
     */
    private function get_plugin_files($plugin_path) {
        $files = array();
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($plugin_path, RecursiveDirectoryIterator::SKIP_DOTS)
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile() && in_array($file->getExtension(), array('php', 'js', 'css'))) {
                $files[] = $file->getPathname();
            }
        }
        
        return $files;
    }

    /**
     * Get plugin information.
     *
     * @since    1.0.0
     * @param    string    $plugin_slug     Plugin slug.
     * @return   array                      Plugin information.
     */
    private function get_plugin_info($plugin_slug) {
        $plugin_file = $plugin_slug . '/' . $plugin_slug . '.php';
        $plugin_file_path = WP_PLUGIN_DIR . '/' . $plugin_file;
        if (!file_exists($plugin_file_path)) {
            return array(
                'slug' => $plugin_slug,
                'name' => '',
                'version' => '',
                'author' => '',
                'description' => '',
                'is_active' => false
            );
        }
        $plugin_data = get_plugin_data($plugin_file_path);
        
        return array(
            'slug' => $plugin_slug,
            'name' => $plugin_data['Name'],
            'version' => $plugin_data['Version'],
            'author' => $plugin_data['Author'],
            'description' => $plugin_data['Description'],
            'is_active' => is_plugin_active($plugin_file)
        );
    }

    /**
     * Check plugin-specific vulnerabilities.
     *
     * @since    1.0.0
     * @param    array     $plugin_info     Plugin information.
     * @return   array                      Plugin vulnerabilities.
     */
    private function check_plugin_vulnerabilities($plugin_info) {
        return $this->vuln_database->check_plugin_vulnerabilities($plugin_info);
    }

    /**
     * Clear detection cache.
     *
     * @since    1.0.0
     */
    public function clear_cache() {
        $this->detection_cache = array();
    }

    /**
     * Get configuration.
     *
     * @since    1.0.0
     * @return   array    Configuration array.
     */
    public function get_config() {
        return $this->config;
    }

    /**
     * Update configuration.
     *
     * @since    1.0.0
     * @param    array    $config    New configuration.
     */
    public function update_config($config) {
        $this->config = wp_parse_args($config, $this->config);
        update_option('wp_breach_classifier_config', $this->config);
    }

    /**
     * Get detection statistics.
     *
     * @since    1.0.0
     * @return   array    Detection statistics.
     */
    public function get_statistics() {
        return array(
            'total_detectors' => count($this->detectors),
            'cache_size' => count($this->detection_cache),
            'version' => $this->version,
            'config' => $this->config
        );
    }
}
