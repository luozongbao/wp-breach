<?php

/**
 * Real-time Malware Scanner for WP-Breach.
 *
 * This class handles real-time scanning of files for malware, malicious code,
 * and suspicious patterns using signature-based and heuristic analysis.
 *
 * @link       https://wpbreach.com
 * @since      1.0.0
 *
 * @package    WP_Breach
 * @subpackage WP_Breach/includes/monitoring
 */

/**
 * The malware scanning class.
 *
 * Performs real-time malware detection using multiple analysis methods
 * including signature matching, heuristic analysis, and behavioral patterns.
 *
 * @since      1.0.0
 * @package    WP_Breach
 * @subpackage WP_Breach/includes/monitoring
 * @author     WP Breach Team
 */
class WP_Breach_Malware_Scanner {

    /**
     * Scanner configuration.
     *
     * @since    1.0.0
     * @access   private
     * @var      array    $config    Scanner configuration.
     */
    private $config;

    /**
     * Malware signatures database.
     *
     * @since    1.0.0
     * @access   private
     * @var      array    $signatures    Malware signatures.
     */
    private $signatures;

    /**
     * Heuristic rules.
     *
     * @since    1.0.0
     * @access   private
     * @var      array    $heuristic_rules    Heuristic analysis rules.
     */
    private $heuristic_rules;

    /**
     * Quarantine manager.
     *
     * @since    1.0.0
     * @access   private
     * @var      WP_Breach_Quarantine_Manager    $quarantine    Quarantine manager.
     */
    private $quarantine;

    /**
     * Scanner cache.
     *
     * @since    1.0.0
     * @access   private
     * @var      array    $scan_cache    Cached scan results.
     */
    private $scan_cache;

    /**
     * Initialize the malware scanner.
     *
     * @since    1.0.0
     */
    public function __construct() {
        $this->setup_config();
        $this->load_signatures();
        $this->setup_heuristic_rules();
        $this->quarantine = new WP_Breach_Quarantine_Manager();
        $this->scan_cache = array();
        
        // Register hooks
        $this->register_hooks();
        
        // Schedule signature updates
        $this->schedule_signature_updates();
    }

    /**
     * Setup scanner configuration.
     *
     * @since    1.0.0
     * @access   private
     */
    private function setup_config() {
        $this->config = array(
            'real_time_scanning' => true,
            'upload_scanning' => true,
            'deep_scanning' => true,
            'heuristic_analysis' => true,
            'behavioral_analysis' => true,
            'signature_updates' => true,
            'auto_quarantine' => true,
            'scan_timeout' => 30, // seconds
            'max_file_size' => 50 * 1024 * 1024, // 50MB
            'scan_cache_ttl' => 3600, // 1 hour
            'quarantine_retention' => 30 * DAY_IN_SECONDS,
            'threat_score_threshold' => 70,
            'auto_clean_enabled' => false,
            'whitelist_enabled' => true,
            'scan_archives' => true,
            'scan_compressed' => true,
            'performance_mode' => 'balanced', // conservative, balanced, aggressive
            'excluded_extensions' => array('jpg', 'jpeg', 'png', 'gif', 'pdf', 'mp3', 'mp4', 'avi'),
            'high_risk_extensions' => array('php', 'phtml', 'php3', 'php4', 'php5', 'pl', 'py', 'jsp', 'asp', 'sh'),
            'suspicious_functions' => array(
                'eval', 'exec', 'system', 'shell_exec', 'passthru', 'base64_decode',
                'file_get_contents', 'file_put_contents', 'fopen', 'fwrite', 'curl_exec'
            )
        );
    }

    /**
     * Load malware signatures.
     *
     * @since    1.0.0
     * @access   private
     */
    private function load_signatures() {
        $this->signatures = array(
            'php_backdoors' => array(
                // Common PHP backdoor patterns
                '/eval\s*\(\s*base64_decode\s*\(/i',
                '/eval\s*\(\s*\$_(?:GET|POST|REQUEST|COOKIE)\s*\[/i',
                '/assert\s*\(\s*\$_(?:GET|POST|REQUEST|COOKIE)\s*\[/i',
                '/preg_replace\s*\(\s*["\'].*\/e["\'].*\$_(?:GET|POST|REQUEST)/i',
                '/create_function\s*\(\s*["\']["\'],\s*\$_(?:GET|POST|REQUEST)/i',
                '/\$\w+\s*=\s*\$_(?:GET|POST|REQUEST|COOKIE)\s*\[\s*["\'][\w\d]+["\']\s*\];\s*\$\w+\s*\(/i'
            ),
            'web_shells' => array(
                // Web shell signatures
                '/\$_FILES\[[\'"]\w+[\'\"]\]\[[\'"](tmp_)?name[\'\"]\]/i',
                '/move_uploaded_file\s*\(\s*\$_FILES/i',
                '/php_uname\s*\(\s*[\'"]a[\'"]\s*\)/i',
                '/<\?php.*system\s*\(\s*\$_(?:GET|POST|REQUEST)/is',
                '/\bpassthru\s*\(\s*\$_(?:GET|POST|REQUEST)/i',
                '/\bshell_exec\s*\(\s*\$_(?:GET|POST|REQUEST)/i'
            ),
            'injected_code' => array(
                // Injected malicious code
                '/<script[^>]*>.*?(?:document\.write|eval|unescape).*?<\/script>/is',
                '/String\.fromCharCode\s*\(\s*[\d\s,]+\)/i',
                '/unescape\s*\(\s*[\'"][%\w\d]+[\'"]\s*\)/i',
                '/document\.write\s*\(\s*unescape\s*\(/i',
                '/iframe[^>]*src\s*=\s*[\'"]https?:\/\/[^\'">]+/i'
            ),
            'obfuscated_patterns' => array(
                // Obfuscated malicious code
                '/str_rot13\s*\(\s*[\'"][a-zA-Z0-9+\/=]{20,}[\'"]\s*\)/i',
                '/gzinflate\s*\(\s*base64_decode\s*\(/i',
                '/gzuncompress\s*\(\s*base64_decode\s*\(/i',
                '/base64_decode\s*\(\s*[\'"][a-zA-Z0-9+\/=]{50,}[\'"]\s*\)/i',
                '/\$\w+\s*=\s*[\'"][a-zA-Z0-9+\/=]{100,}[\'"];\s*eval\s*\(/i'
            ),
            'wordpress_specific' => array(
                // WordPress-specific malware
                '/add_action\s*\(\s*[\'"]wp_head[\'"].*?base64_decode/is',
                '/add_action\s*\(\s*[\'"]init[\'"].*?eval\s*\(/is',
                '/wp_enqueue_script\s*\(.*?base64_decode/is',
                '/\$wp_version\s*=.*?eval\s*\(/i'
            ),
            'crypto_miners' => array(
                // Cryptocurrency mining scripts
                '/coinhive\.com/i',
                '/cnhv\.co/i',
                '/coin-hive\.com/i',
                '/cryptoloot\.pro/i',
                '/jsecoin\.com/i',
                '/authedmine\.com/i'
            ),
            'seo_spam' => array(
                // SEO spam injections
                '/\b(?:viagra|cialis|pharmacy|casino|poker|lottery|sex|porn)\b.*?href\s*=/is',
                '/<div[^>]*style\s*=\s*[\'"](?:[^\'">]*;)?(?:display\s*:\s*none|visibility\s*:\s*hidden)/is',
                '/<!--[^>]*(?:viagra|cialis|pharmacy|casino|poker).*?-->/is'
            )
        );
    }

    /**
     * Setup heuristic analysis rules.
     *
     * @since    1.0.0
     * @access   private
     */
    private function setup_heuristic_rules() {
        $this->heuristic_rules = array(
            'suspicious_functions' => array(
                'weight' => 20,
                'functions' => $this->config['suspicious_functions']
            ),
            'obfuscation_indicators' => array(
                'weight' => 30,
                'patterns' => array(
                    'excessive_base64',
                    'string_concatenation',
                    'variable_variables',
                    'dynamic_function_calls'
                )
            ),
            'network_activity' => array(
                'weight' => 25,
                'indicators' => array(
                    'remote_file_inclusion',
                    'curl_requests',
                    'socket_connections',
                    'external_redirects'
                )
            ),
            'file_operations' => array(
                'weight' => 20,
                'operations' => array(
                    'file_creation',
                    'file_modification',
                    'directory_traversal',
                    'upload_handling'
                )
            ),
            'code_characteristics' => array(
                'weight' => 15,
                'characteristics' => array(
                    'compressed_code',
                    'encrypted_strings',
                    'unusual_file_names',
                    'hidden_functionality'
                )
            )
        );
    }

    /**
     * Register WordPress hooks.
     *
     * @since    1.0.0
     * @access   private
     */
    private function register_hooks() {
        // File upload scanning
        add_filter('wp_handle_upload_prefilter', array($this, 'scan_upload_prefilter'));
        add_filter('wp_handle_upload', array($this, 'scan_uploaded_file'));
        
        // File monitoring integration
        add_action('wp_breach_file_changed', array($this, 'scan_changed_file'));
        add_action('wp_breach_file_created', array($this, 'scan_new_file'));
        
        // Real-time scanning hooks
        add_action('wp_loaded', array($this, 'scan_request_files'), 5);
        
        // Scheduled scanning
        add_action('wp_breach_malware_scan', array($this, 'perform_scheduled_scan'));
        add_action('wp_breach_update_signatures', array($this, 'update_signatures'));
        add_action('wp_breach_quarantine_cleanup', array($this, 'cleanup_quarantine'));
        
        // Emergency response
        add_action('wp_breach_malware_detected', array($this, 'emergency_response'));
    }

    /**
     * Schedule signature updates and maintenance.
     *
     * @since    1.0.0
     * @access   private
     */
    private function schedule_signature_updates() {
        // Daily signature updates
        if (!wp_next_scheduled('wp_breach_update_signatures')) {
            wp_schedule_event(time(), 'daily', 'wp_breach_update_signatures');
        }
        
        // Weekly quarantine cleanup
        if (!wp_next_scheduled('wp_breach_quarantine_cleanup')) {
            wp_schedule_event(time(), 'weekly', 'wp_breach_quarantine_cleanup');
        }
        
        // Hourly scanning for high-risk files
        if (!wp_next_scheduled('wp_breach_malware_scan')) {
            wp_schedule_event(time(), 'hourly', 'wp_breach_malware_scan');
        }
    }

    /**
     * Scan file for malware.
     *
     * @since    1.0.0
     * @param    string   $file_path    Path to file to scan.
     * @return   array                  Scan results.
     */
    public function scan_file($file_path) {
        try {
            // Validate file path
            if (!file_exists($file_path) || !is_readable($file_path)) {
                return array(
                    'success' => false,
                    'error' => 'File not found or not readable'
                );
            }
            
            // Check file size limits
            $file_size = filesize($file_path);
            if ($file_size > $this->config['max_file_size']) {
                return array(
                    'success' => false,
                    'error' => 'File too large for scanning'
                );
            }
            
            // Check cache first
            $cache_key = $this->get_cache_key($file_path);
            if (isset($this->scan_cache[$cache_key])) {
                return $this->scan_cache[$cache_key];
            }
            
            $scan_start = microtime(true);
            
            // Initialize scan results
            $scan_results = array(
                'file_path' => $file_path,
                'file_size' => $file_size,
                'scan_time' => current_time('mysql'),
                'threat_score' => 0,
                'is_malicious' => false,
                'threats_detected' => array(),
                'scan_methods' => array()
            );
            
            // Read file content
            $file_content = file_get_contents($file_path);
            if ($file_content === false) {
                return array(
                    'success' => false,
                    'error' => 'Unable to read file content'
                );
            }
            
            // Signature-based scanning
            $signature_results = $this->signature_scan($file_content, $file_path);
            $scan_results = array_merge_recursive($scan_results, $signature_results);
            $scan_results['scan_methods'][] = 'signature_based';
            
            // Heuristic analysis
            if ($this->config['heuristic_analysis']) {
                $heuristic_results = $this->heuristic_analysis($file_content, $file_path);
                $scan_results['threat_score'] += $heuristic_results['threat_score'];
                $scan_results['threats_detected'] = array_merge(
                    $scan_results['threats_detected'],
                    $heuristic_results['threats_detected']
                );
                $scan_results['scan_methods'][] = 'heuristic_analysis';
            }
            
            // Behavioral analysis for PHP files
            if ($this->config['behavioral_analysis'] && $this->is_executable_file($file_path)) {
                $behavioral_results = $this->behavioral_analysis($file_content, $file_path);
                $scan_results['threat_score'] += $behavioral_results['threat_score'];
                $scan_results['threats_detected'] = array_merge(
                    $scan_results['threats_detected'],
                    $behavioral_results['threats_detected']
                );
                $scan_results['scan_methods'][] = 'behavioral_analysis';
            }
            
            // Calculate final threat assessment
            $scan_results['is_malicious'] = $scan_results['threat_score'] >= $this->config['threat_score_threshold'];
            $scan_results['threat_level'] = $this->calculate_threat_level($scan_results['threat_score']);
            $scan_results['scan_duration'] = microtime(true) - $scan_start;
            $scan_results['success'] = true;
            
            // Cache results
            $this->scan_cache[$cache_key] = $scan_results;
            
            // Handle malicious files
            if ($scan_results['is_malicious']) {
                $this->handle_malicious_file($file_path, $scan_results);
            }
            
            // Log scan results
            $this->log_scan_results($scan_results);
            
            return $scan_results;

        } catch (Exception $e) {
            error_log("WP-Breach Malware Scan Error for {$file_path}: " . $e->getMessage());
            return array(
                'success' => false,
                'error' => $e->getMessage()
            );
        }
    }

    /**
     * Perform signature-based malware detection.
     *
     * @since    1.0.0
     * @access   private
     * @param    string   $file_content    File content.
     * @param    string   $file_path       File path.
     * @return   array                     Signature scan results.
     */
    private function signature_scan($file_content, $file_path) {
        $threats_detected = array();
        $threat_score = 0;
        
        foreach ($this->signatures as $category => $patterns) {
            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $file_content, $matches)) {
                    $threat = array(
                        'type' => 'signature_match',
                        'category' => $category,
                        'pattern' => $pattern,
                        'match' => $matches[0] ?? '',
                        'severity' => $this->get_signature_severity($category),
                        'description' => $this->get_signature_description($category)
                    );
                    
                    $threats_detected[] = $threat;
                    $threat_score += $this->get_signature_score($category);
                }
            }
        }
        
        return array(
            'threats_detected' => $threats_detected,
            'threat_score' => $threat_score
        );
    }

    /**
     * Perform heuristic analysis.
     *
     * @since    1.0.0
     * @access   private
     * @param    string   $file_content    File content.
     * @param    string   $file_path       File path.
     * @return   array                     Heuristic analysis results.
     */
    private function heuristic_analysis($file_content, $file_path) {
        $threats_detected = array();
        $threat_score = 0;
        
        // Check for suspicious functions
        $suspicious_function_score = $this->analyze_suspicious_functions($file_content);
        if ($suspicious_function_score > 0) {
            $threats_detected[] = array(
                'type' => 'suspicious_functions',
                'severity' => 'medium',
                'score' => $suspicious_function_score,
                'description' => 'File contains suspicious PHP functions'
            );
            $threat_score += $suspicious_function_score;
        }
        
        // Check for obfuscation
        $obfuscation_score = $this->analyze_obfuscation($file_content);
        if ($obfuscation_score > 0) {
            $threats_detected[] = array(
                'type' => 'code_obfuscation',
                'severity' => 'high',
                'score' => $obfuscation_score,
                'description' => 'File contains obfuscated code'
            );
            $threat_score += $obfuscation_score;
        }
        
        // Check for network activity indicators
        $network_score = $this->analyze_network_activity($file_content);
        if ($network_score > 0) {
            $threats_detected[] = array(
                'type' => 'network_activity',
                'severity' => 'medium',
                'score' => $network_score,
                'description' => 'File contains network activity indicators'
            );
            $threat_score += $network_score;
        }
        
        // Check file characteristics
        $file_score = $this->analyze_file_characteristics($file_path, $file_content);
        if ($file_score > 0) {
            $threats_detected[] = array(
                'type' => 'suspicious_file_characteristics',
                'severity' => 'low',
                'score' => $file_score,
                'description' => 'File has suspicious characteristics'
            );
            $threat_score += $file_score;
        }
        
        return array(
            'threats_detected' => $threats_detected,
            'threat_score' => $threat_score
        );
    }

    /**
     * Analyze suspicious functions in code.
     *
     * @since    1.0.0
     * @access   private
     * @param    string   $file_content    File content.
     * @return   int                       Threat score.
     */
    private function analyze_suspicious_functions($file_content) {
        $score = 0;
        $suspicious_functions = $this->config['suspicious_functions'];
        
        foreach ($suspicious_functions as $function) {
            $pattern = '/\b' . preg_quote($function, '/') . '\s*\(/i';
            $count = preg_match_all($pattern, $file_content);
            
            if ($count > 0) {
                // Higher scores for more dangerous functions
                $function_scores = array(
                    'eval' => 15,
                    'exec' => 12,
                    'system' => 12,
                    'shell_exec' => 12,
                    'passthru' => 10,
                    'base64_decode' => 5
                );
                
                $function_score = $function_scores[$function] ?? 3;
                $score += $function_score * min($count, 3); // Cap at 3 occurrences
            }
        }
        
        return $score;
    }

    /**
     * Analyze code obfuscation patterns.
     *
     * @since    1.0.0
     * @access   private
     * @param    string   $file_content    File content.
     * @return   int                       Threat score.
     */
    private function analyze_obfuscation($file_content) {
        $score = 0;
        
        // Check for base64 strings (longer than 50 characters)
        $base64_count = preg_match_all('/[a-zA-Z0-9+\/]{50,}={0,2}/', $file_content);
        if ($base64_count > 2) {
            $score += min($base64_count * 5, 25);
        }
        
        // Check for variable variables ($$variable)
        $var_var_count = preg_match_all('/\$\$\w+/', $file_content);
        if ($var_var_count > 0) {
            $score += min($var_var_count * 3, 15);
        }
        
        // Check for dynamic function calls
        $dynamic_calls = preg_match_all('/\$\w+\s*\([^)]*\)/', $file_content);
        if ($dynamic_calls > 3) {
            $score += min($dynamic_calls * 2, 20);
        }
        
        // Check for string concatenation patterns (potential obfuscation)
        $concat_patterns = preg_match_all('/[\'"][^\'"]*[\'"]\.[\s]*[\'"][^\'"]*[\'"]/', $file_content);
        if ($concat_patterns > 10) {
            $score += min($concat_patterns, 15);
        }
        
        return $score;
    }

    /**
     * Analyze network activity indicators.
     *
     * @since    1.0.0
     * @access   private
     * @param    string   $file_content    File content.
     * @return   int                       Threat score.
     */
    private function analyze_network_activity($file_content) {
        $score = 0;
        
        // Check for curl usage
        if (preg_match('/curl_exec\s*\(/', $file_content)) {
            $score += 8;
        }
        
        // Check for file_get_contents with URLs
        if (preg_match('/file_get_contents\s*\(\s*[\'"]https?:\/\//', $file_content)) {
            $score += 10;
        }
        
        // Check for socket connections
        if (preg_match('/fsockopen\s*\(|socket_create\s*\(/', $file_content)) {
            $score += 12;
        }
        
        // Check for remote file inclusion patterns
        if (preg_match('/include\s*\(\s*[\'"]https?:\/\/|require\s*\(\s*[\'"]https?:\/\//', $file_content)) {
            $score += 15;
        }
        
        return $score;
    }

    /**
     * Behavioral analysis for executable files.
     *
     * @since    1.0.0
     * @access   private
     * @param    string   $file_content    File content.
     * @param    string   $file_path       File path.
     * @return   array                     Behavioral analysis results.
     */
    private function behavioral_analysis($file_content, $file_path) {
        $threats_detected = array();
        $threat_score = 0;
        
        // Analyze code structure
        $structure_score = $this->analyze_code_structure($file_content);
        if ($structure_score > 0) {
            $threats_detected[] = array(
                'type' => 'suspicious_code_structure',
                'severity' => 'medium',
                'score' => $structure_score,
                'description' => 'Unusual code structure detected'
            );
            $threat_score += $structure_score;
        }
        
        // Check for backdoor patterns
        $backdoor_score = $this->analyze_backdoor_patterns($file_content);
        if ($backdoor_score > 0) {
            $threats_detected[] = array(
                'type' => 'backdoor_patterns',
                'severity' => 'high',
                'score' => $backdoor_score,
                'description' => 'Potential backdoor functionality detected'
            );
            $threat_score += $backdoor_score;
        }
        
        return array(
            'threats_detected' => $threats_detected,
            'threat_score' => $threat_score
        );
    }

    /**
     * Handle detection of malicious file.
     *
     * @since    1.0.0
     * @access   private
     * @param    string   $file_path       Path to malicious file.
     * @param    array    $scan_results    Scan results.
     */
    private function handle_malicious_file($file_path, $scan_results) {
        // Auto-quarantine if enabled
        if ($this->config['auto_quarantine']) {
            $quarantine_result = $this->quarantine->quarantine_file($file_path, $scan_results);
            
            if ($quarantine_result['success']) {
                $scan_results['quarantined'] = true;
                $scan_results['quarantine_id'] = $quarantine_result['quarantine_id'];
            }
        }
        
        // Create security alert
        $this->create_malware_alert($file_path, $scan_results);
        
        // Trigger emergency response
        do_action('wp_breach_malware_detected', $file_path, $scan_results);
        
        // Log critical event
        error_log("WP-Breach: MALWARE DETECTED - {$file_path} - Threat Score: {$scan_results['threat_score']}");
    }

    /**
     * Create malware detection alert.
     *
     * @since    1.0.0
     * @access   private
     * @param    string   $file_path       File path.
     * @param    array    $scan_results    Scan results.
     */
    private function create_malware_alert($file_path, $scan_results) {
        $alert_manager = new WP_Breach_Alert_Manager();
        
        $severity = $scan_results['threat_score'] >= 90 ? 'critical' : 'high';
        
        $alert_data = array(
            'type' => 'malware_detected',
            'severity' => $severity,
            'title' => 'Malware Detected',
            'message' => sprintf(
                'Malicious file detected: %s (Threat Score: %d)',
                basename($file_path),
                $scan_results['threat_score']
            ),
            'details' => array(
                'file_path' => $file_path,
                'threat_score' => $scan_results['threat_score'],
                'threats_detected' => $scan_results['threats_detected'],
                'quarantined' => $scan_results['quarantined'] ?? false
            ),
            'source' => 'malware_scanner'
        );
        
        $alert_manager->create_alert($alert_data);
    }

    /**
     * Scan upload before processing.
     *
     * @since    1.0.0
     * @param    array    $file    Upload file data.
     * @return   array             Modified file data.
     */
    public function scan_upload_prefilter($file) {
        if (!$this->config['upload_scanning']) {
            return $file;
        }
        
        // Check file extension
        $file_extension = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION));
        
        if (in_array($file_extension, $this->config['high_risk_extensions'])) {
            // Scan high-risk files immediately
            $scan_results = $this->scan_file($file['tmp_name']);
            
            if ($scan_results['success'] && $scan_results['is_malicious']) {
                $file['error'] = 'Malicious file detected. Upload blocked for security reasons.';
            }
        }
        
        return $file;
    }

    /**
     * Scan uploaded file after processing.
     *
     * @since    1.0.0
     * @param    array    $upload    Upload result.
     * @return   array              Modified upload result.
     */
    public function scan_uploaded_file($upload) {
        if (!$this->config['upload_scanning'] || !empty($upload['error'])) {
            return $upload;
        }
        
        // Scan the uploaded file
        $scan_results = $this->scan_file($upload['file']);
        
        if ($scan_results['success'] && $scan_results['is_malicious']) {
            // Remove malicious file
            if (file_exists($upload['file'])) {
                unlink($upload['file']);
            }
            
            $upload['error'] = 'Malicious content detected in uploaded file.';
        }
        
        return $upload;
    }

    /**
     * Emergency response to malware detection.
     *
     * @since    1.0.0
     * @param    string   $file_path       Malicious file path.
     * @param    array    $scan_results    Scan results.
     */
    public function emergency_response($file_path, $scan_results) {
        // Implement emergency response procedures
        
        // 1. Immediate file isolation
        if ($scan_results['threat_score'] >= 90) {
            // Critical threat - immediate action
            $this->quarantine->emergency_quarantine($file_path);
        }
        
        // 2. Network traffic monitoring
        if ($this->contains_network_activity($scan_results)) {
            // Monitor for suspicious network activity
            do_action('wp_breach_monitor_network_activity', $file_path);
        }
        
        // 3. Access logging
        $this->log_file_access($file_path);
        
        // 4. User notification
        if ($scan_results['threat_score'] >= 80) {
            // Notify administrators immediately
            do_action('wp_breach_emergency_notification', $file_path, $scan_results);
        }
    }

    /**
     * Update malware signatures.
     *
     * @since    1.0.0
     */
    public function update_signatures() {
        if (!$this->config['signature_updates']) {
            return;
        }
        
        try {
            // Fetch updated signatures from threat intelligence service
            $threat_intel = new WP_Breach_Threat_Intelligence();
            $updated_signatures = $threat_intel->get_malware_signatures();
            
            if (!empty($updated_signatures)) {
                // Merge with existing signatures
                $this->signatures = array_merge_recursive($this->signatures, $updated_signatures);
                
                // Cache updated signatures
                update_option('wp_breach_malware_signatures', $this->signatures);
                update_option('wp_breach_signatures_updated', time());
                
                error_log('WP-Breach: Malware signatures updated successfully');
            }

        } catch (Exception $e) {
            error_log('WP-Breach: Failed to update malware signatures: ' . $e->getMessage());
        }
    }

    /**
     * Clean up old quarantine files.
     *
     * @since    1.0.0
     */
    public function cleanup_quarantine() {
        $this->quarantine->cleanup_old_files();
    }

    /**
     * Perform scheduled malware scan.
     *
     * @since    1.0.0
     */
    public function perform_scheduled_scan() {
        // Scan high-risk directories
        $high_risk_paths = array(
            wp_upload_dir()['basedir'],
            WP_PLUGIN_DIR,
            get_theme_root()
        );
        
        foreach ($high_risk_paths as $path) {
            $this->scan_directory($path, array('recursive' => false, 'limit' => 50));
        }
    }

    /**
     * Scan directory for malware.
     *
     * @since    1.0.0
     * @param    string   $directory    Directory path.
     * @param    array    $options      Scan options.
     */
    public function scan_directory($directory, $options = array()) {
        if (!is_dir($directory)) {
            return;
        }
        
        $recursive = $options['recursive'] ?? true;
        $limit = $options['limit'] ?? 100;
        $scanned = 0;
        
        try {
            $iterator = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($directory, RecursiveDirectoryIterator::SKIP_DOTS),
                $recursive ? RecursiveIteratorIterator::SELF_FIRST : RecursiveIteratorIterator::LEAVES_ONLY
            );
            
            foreach ($iterator as $file) {
                if ($file->isFile() && $scanned < $limit) {
                    $file_path = $file->getRealPath();
                    
                    // Skip excluded extensions
                    $extension = strtolower($file->getExtension());
                    if (in_array($extension, $this->config['excluded_extensions'])) {
                        continue;
                    }
                    
                    // Scan file
                    $this->scan_file($file_path);
                    $scanned++;
                }
            }

        } catch (Exception $e) {
            error_log("WP-Breach Directory Scan Error for {$directory}: " . $e->getMessage());
        }
    }

    // Helper methods...
    
    private function get_cache_key($file_path) {
        return md5($file_path . filemtime($file_path));
    }
    
    private function is_executable_file($file_path) {
        $extension = strtolower(pathinfo($file_path, PATHINFO_EXTENSION));
        return in_array($extension, $this->config['high_risk_extensions']);
    }
    
    private function calculate_threat_level($threat_score) {
        if ($threat_score >= 90) return 'critical';
        if ($threat_score >= 70) return 'high';
        if ($threat_score >= 40) return 'medium';
        if ($threat_score >= 20) return 'low';
        return 'clean';
    }
    
    private function get_signature_severity($category) {
        $severities = array(
            'php_backdoors' => 'critical',
            'web_shells' => 'critical',
            'injected_code' => 'high',
            'obfuscated_patterns' => 'high',
            'wordpress_specific' => 'high',
            'crypto_miners' => 'medium',
            'seo_spam' => 'low'
        );
        
        return $severities[$category] ?? 'medium';
    }
    
    private function get_signature_score($category) {
        $scores = array(
            'php_backdoors' => 40,
            'web_shells' => 40,
            'injected_code' => 30,
            'obfuscated_patterns' => 25,
            'wordpress_specific' => 30,
            'crypto_miners' => 20,
            'seo_spam' => 10
        );
        
        return $scores[$category] ?? 15;
    }
    
    private function get_signature_description($category) {
        $descriptions = array(
            'php_backdoors' => 'PHP backdoor or remote shell detected',
            'web_shells' => 'Web shell or command execution interface detected',
            'injected_code' => 'Injected malicious JavaScript or HTML detected',
            'obfuscated_patterns' => 'Obfuscated malicious code patterns detected',
            'wordpress_specific' => 'WordPress-specific malware detected',
            'crypto_miners' => 'Cryptocurrency mining script detected',
            'seo_spam' => 'SEO spam injection detected'
        );
        
        return $descriptions[$category] ?? 'Suspicious code pattern detected';
    }
    
    private function analyze_file_characteristics($file_path, $file_content) {
        $score = 0;
        
        // Check file name patterns
        $filename = basename($file_path);
        if (preg_match('/^[a-f0-9]{32}\.php$|^[0-9]+\.php$|^wp-[a-z0-9]+\.php$/', $filename)) {
            $score += 10;
        }
        
        // Check for hidden files in uploads
        if (strpos($file_path, wp_upload_dir()['basedir']) === 0 && strpos($filename, '.') === 0) {
            $score += 15;
        }
        
        // Check code density (high density might indicate obfuscation)
        $code_density = strlen(preg_replace('/\s+/', '', $file_content)) / strlen($file_content);
        if ($code_density > 0.8) {
            $score += 10;
        }
        
        return $score;
    }
    
    private function analyze_code_structure($file_content) {
        $score = 0;
        
        // Check for single-line PHP files (often malicious)
        $line_count = substr_count($file_content, "\n");
        if ($line_count < 5 && strlen($file_content) > 100) {
            $score += 20;
        }
        
        // Check for excessive nesting or complexity
        $brace_count = substr_count($file_content, '{');
        if ($brace_count > 50 && $line_count < 100) {
            $score += 15;
        }
        
        return $score;
    }
    
    private function analyze_backdoor_patterns($file_content) {
        $score = 0;
        
        // Check for password-protected access
        if (preg_match('/\$_(?:GET|POST|REQUEST|COOKIE)\[[\'"]\w*(?:pass|pwd|auth)[\'"]\]/', $file_content)) {
            $score += 25;
        }
        
        // Check for remote command execution
        if (preg_match('/\$_(?:GET|POST|REQUEST)\[[\'"]\w*[\'"]\].*(?:system|exec|shell_exec|passthru)/', $file_content)) {
            $score += 30;
        }
        
        return $score;
    }
    
    private function log_scan_results($scan_results) {
        global $wpdb;
        
        $table_name = $wpdb->prefix . 'breach_monitoring';
        
        $wpdb->insert(
            $table_name,
            array(
                'monitor_type' => 'malware_scan',
                'file_path' => $scan_results['file_path'],
                'threat_score' => $scan_results['threat_score'],
                'is_malicious' => $scan_results['is_malicious'] ? 1 : 0,
                'scan_results' => json_encode($scan_results),
                'detected_at' => $scan_results['scan_time'],
                'created_at' => current_time('mysql')
            ),
            array('%s', '%s', '%d', '%d', '%s', '%s', '%s')
        );
    }
    
    private function contains_network_activity($scan_results) {
        foreach ($scan_results['threats_detected'] as $threat) {
            if ($threat['type'] === 'network_activity') {
                return true;
            }
        }
        return false;
    }
    
    private function log_file_access($file_path) {
        // Log any attempts to access the malicious file
        error_log("WP-Breach: Monitoring access to malicious file: {$file_path}");
    }

    // File change monitoring integration
    public function scan_changed_file($file_path) {
        if ($this->config['real_time_scanning']) {
            wp_schedule_single_event(time() + 10, 'wp_breach_scan_file', array($file_path));
        }
    }

    public function scan_new_file($file_path) {
        if ($this->config['real_time_scanning']) {
            wp_schedule_single_event(time() + 5, 'wp_breach_scan_file', array($file_path));
        }
    }

    public function scan_request_files() {
        // Scan any files included in current request
        if ($this->config['real_time_scanning']) {
            $included_files = get_included_files();
            
            foreach ($included_files as $file) {
                // Only scan recently modified files
                if (filemtime($file) > (time() - 3600)) { // Last hour
                    $cache_key = $this->get_cache_key($file);
                    if (!isset($this->scan_cache[$cache_key])) {
                        wp_schedule_single_event(time() + 30, 'wp_breach_scan_file', array($file));
                    }
                }
            }
        }
    }
}
