<?php
/**
 * Vulnerability model class for database operations.
 *
 * @link       https://github.com/luozongbao
 * @since      1.0.0
 *
 * @package    WP_Breach
 * @subpackage WP_Breach/includes/database
 */

/**
 * Vulnerability model class for database operations.
 *
 * Handles all database operations related to detected vulnerabilities
 * including creation, updates, resolution tracking, and analysis.
 *
 * @package    WP_Breach
 * @subpackage WP_Breach/includes/database
 * @author     luozongbao <luo.zongbao@outlook.com>
 */
class WP_Breach_Vulnerability_Model extends WP_Breach_Base_Model {

	/**
	 * Get the table suffix for this model.
	 *
	 * @since    1.0.0
	 * @return   string    The table suffix.
	 */
	protected function get_table_suffix() {
		return 'breach_vulnerabilities';
	}

	/**
	 * Get the validation rules for this model.
	 *
	 * @since    1.0.0
	 * @return   array    The validation rules.
	 */
	protected function get_validation_rules() {
		return array(
			'scan_id' => array(
				'required' => true,
				'type'     => 'integer',
			),
			'vulnerability_type' => array(
				'required'   => true,
				'type'       => 'string',
				'max_length' => 50,
			),
			'severity' => array(
				'required'   => true,
				'type'       => 'string',
				'max_length' => 20,
			),
			'title' => array(
				'required'   => true,
				'type'       => 'string',
				'max_length' => 255,
			),
			'description' => array(
				'required' => true,
				'type'     => 'string',
			),
			'file_path' => array(
				'type'       => 'string',
				'max_length' => 500,
			),
		);
	}

	/**
	 * Create a new vulnerability record.
	 *
	 * @since    1.0.0
	 * @param    array    $data    The vulnerability data.
	 * @return   int|false    The vulnerability ID or false on failure.
	 */
	public function create_vulnerability( $data ) {
		$defaults = array(
			'status'           => 'active',
			'risk_score'       => 0,
			'discovered_at'    => current_time( 'mysql' ),
			'false_positive'   => 0,
		);

		$data = wp_parse_args( $data, $defaults );

		// Calculate risk score if not provided
		if ( empty( $data['risk_score'] ) ) {
			$data['risk_score'] = $this->calculate_risk_score( $data );
		}

		// Generate vulnerability hash for deduplication
		$data['vulnerability_hash'] = $this->generate_vulnerability_hash( $data );

		return $this->create( $data );
	}

	/**
	 * Update vulnerability status.
	 *
	 * @since    1.0.0
	 * @param    int      $vulnerability_id    The vulnerability ID.
	 * @param    string   $status              The new status.
	 * @param    array    $data                Additional data to update.
	 * @return   bool     True on success, false on failure.
	 */
	public function update_vulnerability_status( $vulnerability_id, $status, $data = array() ) {
		$update_data = array_merge( $data, array( 'status' => $status ) );

		// Set resolution time for resolved vulnerabilities
		if ( $status === 'resolved' ) {
			$update_data['resolved_at'] = current_time( 'mysql' );
		}

		// Set verification time for verified vulnerabilities
		if ( $status === 'verified' ) {
			$update_data['verified_at'] = current_time( 'mysql' );
		}

		return $this->update( $vulnerability_id, $update_data );
	}

	/**
	 * Mark vulnerability as false positive.
	 *
	 * @since    1.0.0
	 * @param    int    $vulnerability_id    The vulnerability ID.
	 * @param    int    $user_id             The user marking it as false positive.
	 * @return   bool   True on success, false on failure.
	 */
	public function mark_false_positive( $vulnerability_id, $user_id = null ) {
		if ( ! $user_id ) {
			$user_id = get_current_user_id();
		}

		return $this->update( $vulnerability_id, array(
			'false_positive'        => 1,
			'status'                => 'false_positive',
			'false_positive_by'     => $user_id,
			'false_positive_at'     => current_time( 'mysql' ),
		) );
	}

	/**
	 * Get vulnerabilities by scan ID.
	 *
	 * @since    1.0.0
	 * @param    int      $scan_id    The scan ID.
	 * @param    array    $args       Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_scan( $scan_id, $args = array() ) {
		$args['where'] = array( 'scan_id' => $scan_id );
		return $this->get_all( $args );
	}

	/**
	 * Get vulnerabilities by severity.
	 *
	 * @since    1.0.0
	 * @param    string   $severity    The severity level.
	 * @param    array    $args        Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_severity( $severity, $args = array() ) {
		$args['where'] = array( 'severity' => $severity );
		
		// Exclude false positives by default
		if ( ! isset( $args['include_false_positives'] ) || ! $args['include_false_positives'] ) {
			$args['where']['false_positive'] = 0;
		}
		
		return $this->get_all( $args );
	}

	/**
	 * Get vulnerabilities by status.
	 *
	 * @since    1.0.0
	 * @param    string   $status    The vulnerability status.
	 * @param    array    $args      Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_status( $status, $args = array() ) {
		$args['where'] = array( 'status' => $status );
		return $this->get_all( $args );
	}

	/**
	 * Get vulnerabilities by type.
	 *
	 * @since    1.0.0
	 * @param    string   $type    The vulnerability type.
	 * @param    array    $args    Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_type( $type, $args = array() ) {
		$args['where'] = array( 'vulnerability_type' => $type );
		return $this->get_all( $args );
	}

	/**
	 * Get active vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    array    $args    Additional query arguments.
	 * @return   array    Array of active vulnerability objects.
	 */
	public function get_active_vulnerabilities( $args = array() ) {
		$args['where'] = array(
			'status'          => 'active',
			'false_positive'  => 0,
		);
		return $this->get_all( $args );
	}

	/**
	 * Get critical vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    array    $args    Additional query arguments.
	 * @return   array    Array of critical vulnerability objects.
	 */
	public function get_critical_vulnerabilities( $args = array() ) {
		$args['where'] = array(
			'severity'        => 'critical',
			'status'          => 'active',
			'false_positive'  => 0,
		);
		return $this->get_all( $args );
	}

	/**
	 * Get vulnerability statistics.
	 *
	 * @since    1.0.0
	 * @param    array    $args    Query arguments (date range, scan ID, etc.).
	 * @return   array    Vulnerability statistics.
	 */
	public function get_vulnerability_statistics( $args = array() ) {
		$where_clause = 'WHERE 1=1';
		$where_params = array();

		// Add date range filter
		if ( ! empty( $args['date_from'] ) ) {
			$where_clause .= ' AND discovered_at >= %s';
			$where_params[] = $args['date_from'];
		}

		if ( ! empty( $args['date_to'] ) ) {
			$where_clause .= ' AND discovered_at <= %s';
			$where_params[] = $args['date_to'];
		}

		// Add scan filter
		if ( ! empty( $args['scan_id'] ) ) {
			$where_clause .= ' AND scan_id = %d';
			$where_params[] = $args['scan_id'];
		}

		// Exclude false positives by default
		if ( ! isset( $args['include_false_positives'] ) || ! $args['include_false_positives'] ) {
			$where_clause .= ' AND false_positive = 0';
		}

		$sql = "SELECT 
			COUNT(*) as total_vulnerabilities,
			SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical_count,
			SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high_count,
			SUM(CASE WHEN severity = 'medium' THEN 1 ELSE 0 END) as medium_count,
			SUM(CASE WHEN severity = 'low' THEN 1 ELSE 0 END) as low_count,
			SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_count,
			SUM(CASE WHEN status = 'resolved' THEN 1 ELSE 0 END) as resolved_count,
			SUM(CASE WHEN status = 'verified' THEN 1 ELSE 0 END) as verified_count,
			SUM(CASE WHEN false_positive = 1 THEN 1 ELSE 0 END) as false_positive_count,
			AVG(risk_score) as avg_risk_score
		FROM {$this->table_name} 
		{$where_clause}";

		if ( ! empty( $where_params ) ) {
			$sql = $this->wpdb->prepare( $sql, $where_params );
		}

		$result = $this->wpdb->get_row( $sql );

		return array(
			'total_vulnerabilities' => intval( $result->total_vulnerabilities ),
			'severity_counts'       => array(
				'critical' => intval( $result->critical_count ),
				'high'     => intval( $result->high_count ),
				'medium'   => intval( $result->medium_count ),
				'low'      => intval( $result->low_count ),
			),
			'status_counts'         => array(
				'active'   => intval( $result->active_count ),
				'resolved' => intval( $result->resolved_count ),
				'verified' => intval( $result->verified_count ),
			),
			'false_positive_count'  => intval( $result->false_positive_count ),
			'avg_risk_score'        => floatval( $result->avg_risk_score ),
		);
	}

	/**
	 * Get vulnerability trends.
	 *
	 * @since    1.0.0
	 * @param    string   $period       Time period (daily, weekly, monthly).
	 * @param    int      $limit        Number of periods to retrieve.
	 * @return   array    Trend data.
	 */
	public function get_vulnerability_trends( $period = 'daily', $limit = 30 ) {
		$date_format = '%Y-%m-%d';
		$interval = '1 DAY';

		switch ( $period ) {
			case 'weekly':
				$date_format = '%Y-%u';
				$interval = '1 WEEK';
				break;
			case 'monthly':
				$date_format = '%Y-%m';
				$interval = '1 MONTH';
				break;
		}

		$sql = "SELECT 
			DATE_FORMAT(discovered_at, '{$date_format}') as period,
			COUNT(*) as total_count,
			SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical_count,
			SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high_count,
			SUM(CASE WHEN severity = 'medium' THEN 1 ELSE 0 END) as medium_count,
			SUM(CASE WHEN severity = 'low' THEN 1 ELSE 0 END) as low_count
		FROM {$this->table_name}
		WHERE discovered_at >= DATE_SUB(NOW(), INTERVAL %d {$interval})
		AND false_positive = 0
		GROUP BY period
		ORDER BY period DESC
		LIMIT %d";

		return $this->wpdb->get_results( $this->wpdb->prepare( $sql, $limit, $limit ) );
	}

	/**
	 * Get vulnerabilities by file path.
	 *
	 * @since    1.0.0
	 * @param    string   $file_path    The file path.
	 * @param    array    $args         Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_file( $file_path, $args = array() ) {
		$args['where'] = array( 'file_path' => $file_path );
		return $this->get_all( $args );
	}

	/**
	 * Get top vulnerable files.
	 *
	 * @since    1.0.0
	 * @param    int    $limit    Number of files to retrieve.
	 * @return   array  Array of file vulnerability data.
	 */
	public function get_top_vulnerable_files( $limit = 10 ) {
		$sql = "SELECT 
			file_path,
			COUNT(*) as vulnerability_count,
			SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical_count,
			SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high_count,
			AVG(risk_score) as avg_risk_score
		FROM {$this->table_name}
		WHERE status = 'active' 
		AND false_positive = 0
		AND file_path IS NOT NULL 
		AND file_path != ''
		GROUP BY file_path
		ORDER BY vulnerability_count DESC, avg_risk_score DESC
		LIMIT %d";

		return $this->wpdb->get_results( $this->wpdb->prepare( $sql, $limit ) );
	}

	/**
	 * Get duplicate vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    string   $vulnerability_hash    The vulnerability hash.
	 * @param    int      $exclude_scan_id       Scan ID to exclude.
	 * @return   array    Array of duplicate vulnerability objects.
	 */
	public function get_duplicate_vulnerabilities( $vulnerability_hash, $exclude_scan_id = null ) {
		$where = array( 'vulnerability_hash' => $vulnerability_hash );
		
		if ( $exclude_scan_id ) {
			$where_clause = 'vulnerability_hash = %s AND scan_id != %d';
			$results = $this->wpdb->get_results( $this->wpdb->prepare(
				"SELECT * FROM {$this->table_name} WHERE {$where_clause}",
				$vulnerability_hash,
				$exclude_scan_id
			) );
		} else {
			$results = $this->get_all( array( 'where' => $where ) );
		}

		return $results;
	}

	/**
	 * Bulk update vulnerability status.
	 *
	 * @since    1.0.0
	 * @param    array    $vulnerability_ids    Array of vulnerability IDs.
	 * @param    string   $status               New status.
	 * @param    array    $additional_data      Additional data to update.
	 * @return   int      Number of vulnerabilities updated.
	 */
	public function bulk_update_status( $vulnerability_ids, $status, $additional_data = array() ) {
		if ( empty( $vulnerability_ids ) ) {
			return 0;
		}

		$ids_placeholder = implode( ',', array_fill( 0, count( $vulnerability_ids ), '%d' ) );
		$update_data = array_merge( $additional_data, array( 'status' => $status ) );

		// Set timestamps based on status
		if ( $status === 'resolved' ) {
			$update_data['resolved_at'] = current_time( 'mysql' );
		} elseif ( $status === 'verified' ) {
			$update_data['verified_at'] = current_time( 'mysql' );
		}

		$set_clause = array();
		$values = array();

		foreach ( $update_data as $column => $value ) {
			$set_clause[] = "{$column} = %s";
			$values[] = $value;
		}

		$sql = "UPDATE {$this->table_name} 
		        SET " . implode( ', ', $set_clause ) . "
		        WHERE id IN ({$ids_placeholder})";

		$values = array_merge( $values, $vulnerability_ids );

		return $this->wpdb->query( $this->wpdb->prepare( $sql, $values ) );
	}

	/**
	 * Delete old resolved vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    int    $days_old    Number of days to keep.
	 * @return   int    Number of vulnerabilities deleted.
	 */
	public function delete_old_resolved( $days_old = 180 ) {
		$cutoff_date = date( 'Y-m-d H:i:s', strtotime( "-{$days_old} days" ) );

		$result = $this->wpdb->query( $this->wpdb->prepare(
			"DELETE FROM {$this->table_name} 
			WHERE status = 'resolved' 
			AND resolved_at < %s",
			$cutoff_date
		) );

		return intval( $result );
	}

	/**
	 * Calculate risk score for a vulnerability.
	 *
	 * @since    1.0.0
	 * @param    array    $data    The vulnerability data.
	 * @return   float    The calculated risk score.
	 */
	private function calculate_risk_score( $data ) {
		$base_scores = array(
			'critical' => 9.0,
			'high'     => 7.0,
			'medium'   => 5.0,
			'low'      => 3.0,
		);

		$severity = $data['severity'] ?? 'low';
		$base_score = $base_scores[ $severity ] ?? 3.0;

		// Adjust score based on vulnerability type
		$type_modifiers = array(
			'sql_injection'     => 1.2,
			'xss'               => 1.1,
			'csrf'              => 1.0,
			'file_inclusion'    => 1.3,
			'command_injection' => 1.4,
			'authentication'    => 1.1,
			'authorization'     => 1.0,
			'information_disclosure' => 0.9,
		);

		$type = $data['vulnerability_type'] ?? '';
		$modifier = $type_modifiers[ $type ] ?? 1.0;

		return min( 10.0, $base_score * $modifier );
	}

	/**
	 * Generate a unique hash for the vulnerability.
	 *
	 * @since    1.0.0
	 * @param    array    $data    The vulnerability data.
	 * @return   string   The generated hash.
	 */
	private function generate_vulnerability_hash( $data ) {
		$hash_data = array(
			'type'        => $data['vulnerability_type'],
			'title'       => $data['title'],
			'file_path'   => $data['file_path'] ?? '',
			'line_number' => $data['line_number'] ?? 0,
		);

		return hash( 'sha256', wp_json_encode( $hash_data ) );
	}

	/**
	 * Get vulnerabilities requiring attention.
	 *
	 * @since    1.0.0
	 * @param    int    $limit    Number of vulnerabilities to retrieve.
	 * @return   array  Array of vulnerability objects that need attention.
	 */
	public function get_vulnerabilities_requiring_attention( $limit = 20 ) {
		$sql = "SELECT * FROM {$this->table_name}
		        WHERE status = 'active' 
		        AND false_positive = 0
		        AND (severity IN ('critical', 'high') 
		             OR discovered_at < DATE_SUB(NOW(), INTERVAL 7 DAY))
		        ORDER BY 
		            CASE severity 
		                WHEN 'critical' THEN 1 
		                WHEN 'high' THEN 2 
		                WHEN 'medium' THEN 3 
		                ELSE 4 
		            END,
		            discovered_at ASC
		        LIMIT %d";

		return $this->wpdb->get_results( $this->wpdb->prepare( $sql, $limit ) );
	}
}
