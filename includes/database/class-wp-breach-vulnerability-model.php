<?php
/**
 * Vulnerability model class for database operations.
 *
 * @link       https://github.com/luozongbao
 * @since      1.0.0
 *
 * @package    WP_Breach
 * @subpackage WP_Breach/includes/database
 */

/**
 * Vulnerability model class for database operations.
 *
 * Handles all database operations related to detected vulnerabilities
 * including creation, updates, resolution tracking, and analysis.
 *
 * @package    WP_Breach
 * @subpackage WP_Breach/includes/database
 * @author     luozongbao <luo.zongbao@outlook.com>
 */
class WP_Breach_Vulnerability_Model extends WP_Breach_Base_Model {

	/**
	 * Get the table suffix for this model.
	 *
	 * @since    1.0.0
	 * @return   string    The table suffix.
	 */
	protected function get_table_suffix() {
		return 'breach_vulnerabilities';
	}

	/**
	 * Get the validation rules for this model.
	 *
	 * @since    1.0.0
	 * @return   array    The validation rules.
	 */
	protected function get_validation_rules() {
		return array(
			'scan_id' => array(
				'required' => true,
				'type'     => 'integer',
			),
			'vulnerability_type' => array(
				'required'   => true,
				'type'       => 'string',
				'max_length' => 50,
			),
			'severity' => array(
				'required'   => true,
				'type'       => 'string',
				'max_length' => 20,
			),
			'title' => array(
				'required'   => true,
				'type'       => 'string',
				'max_length' => 255,
			),
			'description' => array(
				'required' => true,
				'type'     => 'string',
			),
			'file_path' => array(
				'type'       => 'string',
				'max_length' => 500,
			),
		);
	}

	/**
	 * Create a new vulnerability record.
	 *
	 * @since    1.0.0
	 * @param    array    $data    The vulnerability data.
	 * @return   int|false    The vulnerability ID or false on failure.
	 */
	public function create_vulnerability( $data ) {
		$defaults = array(
			'status'           => 'active',
			'risk_score'       => 0,
			'detected_at'    => current_time( 'mysql' ),
			'false_positive'   => 0,
		);

		$data = wp_parse_args( $data, $defaults );

		// Calculate risk score if not provided
		if ( empty( $data['risk_score'] ) ) {
			$data['risk_score'] = $this->calculate_risk_score( $data );
		}

		// Generate vulnerability hash for deduplication
		$data['vulnerability_hash'] = $this->generate_vulnerability_hash( $data );

		return $this->create( $data );
	}

	/**
	 * Update vulnerability status.
	 *
	 * @since    1.0.0
	 * @param    int      $vulnerability_id    The vulnerability ID.
	 * @param    string   $status              The new status.
	 * @param    array    $data                Additional data to update.
	 * @return   bool     True on success, false on failure.
	 */
	public function update_vulnerability_status( $vulnerability_id, $status, $data = array() ) {
		$update_data = array_merge( $data, array( 'status' => $status ) );

		// Set resolution time for resolved vulnerabilities
		if ( $status === 'resolved' ) {
			$update_data['resolved_at'] = current_time( 'mysql' );
		}

		// Set verification time for verified vulnerabilities
		if ( $status === 'verified' ) {
			$update_data['verified_at'] = current_time( 'mysql' );
		}

		return $this->update( $vulnerability_id, $update_data );
	}

	/**
	 * Mark vulnerability as false positive.
	 *
	 * @since    1.0.0
	 * @param    int    $vulnerability_id    The vulnerability ID.
	 * @param    int    $user_id             The user marking it as false positive.
	 * @return   bool   True on success, false on failure.
	 */
	public function mark_false_positive( $vulnerability_id, $user_id = null ) {
		if ( ! $user_id ) {
			$user_id = get_current_user_id();
		}

		return $this->update( $vulnerability_id, array(
			'false_positive'        => 1,
			'status'                => 'false_positive',
			'false_positive_by'     => $user_id,
			'false_positive_at'     => current_time( 'mysql' ),
		) );
	}

	/**
	 * Get vulnerabilities by scan ID.
	 *
	 * @since    1.0.0
	 * @param    int      $scan_id    The scan ID.
	 * @param    array    $args       Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_scan( $scan_id, $args = array() ) {
		$args['where'] = array( 'scan_id' => $scan_id );
		return $this->get_all( $args );
	}

	/**
	 * Get vulnerabilities by severity.
	 *
	 * @since    1.0.0
	 * @param    string   $severity    The severity level.
	 * @param    array|int $args       Additional query arguments or limit if integer.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_severity( $severity, $args = array() ) {
		// Handle legacy calling with limit as second parameter
		if ( is_numeric( $args ) ) {
			$args = array( 'limit' => intval( $args ) );
		}
		
		// Ensure args is an array
		if ( ! is_array( $args ) ) {
			$args = array();
		}
		
		$args['where'] = isset( $args['where'] ) ? $args['where'] : array();
		$args['where']['severity'] = $severity;
		
		// Exclude false positives by default
		if ( ! isset( $args['include_false_positives'] ) || ! $args['include_false_positives'] ) {
			$args['where']['false_positive'] = 0;
		}
		
		return $this->get_all( $args );
	}

	/**
	 * Get vulnerabilities by status.
	 *
	 * @since    1.0.0
	 * @param    string   $status    The vulnerability status.
	 * @param    array    $args      Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_status( $status, $args = array() ) {
		$args['where'] = array( 'status' => $status );
		return $this->get_all( $args );
	}

	/**
	 * Get vulnerabilities by type.
	 *
	 * @since    1.0.0
	 * @param    string   $type    The vulnerability type.
	 * @param    array    $args    Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_type( $type, $args = array() ) {
		$args['where'] = array( 'vulnerability_type' => $type );
		return $this->get_all( $args );
	}

	/**
	 * Get active vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    array    $args    Additional query arguments.
	 * @return   array    Array of active vulnerability objects.
	 */
	public function get_active_vulnerabilities( $args = array() ) {
		$args['where'] = array(
			'status'          => 'active',
			'false_positive'  => 0,
		);
		return $this->get_all( $args );
	}

	/**
	 * Get critical vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    array    $args    Additional query arguments.
	 * @return   array    Array of critical vulnerability objects.
	 */
	public function get_critical_vulnerabilities( $args = array() ) {
		$args['where'] = array(
			'severity'        => 'critical',
			'status'          => 'active',
			'false_positive'  => 0,
		);
		return $this->get_all( $args );
	}

	/**
	 * Get vulnerability statistics.
	 *
	 * @since    1.0.0
	 * @param    array    $args    Query arguments (date range, scan ID, etc.).
	 * @return   array    Vulnerability statistics.
	 */
	public function get_vulnerability_statistics( $args = array() ) {
		$where_clause = 'WHERE 1=1';
		$where_params = array();

		// Add date range filter
		if ( ! empty( $args['date_from'] ) ) {
			$where_clause .= ' AND detected_at >= %s';
			$where_params[] = $args['date_from'];
		}

		if ( ! empty( $args['date_to'] ) ) {
			$where_clause .= ' AND detected_at <= %s';
			$where_params[] = $args['date_to'];
		}

		// Add scan filter
		if ( ! empty( $args['scan_id'] ) ) {
			$where_clause .= ' AND scan_id = %d';
			$where_params[] = $args['scan_id'];
		}

		// Exclude false positives by default
		if ( ! isset( $args['include_false_positives'] ) || ! $args['include_false_positives'] ) {
			$where_clause .= ' AND false_positive = 0';
		}

		$sql = "SELECT 
			COUNT(*) as total_vulnerabilities,
			SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical_count,
			SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high_count,
			SUM(CASE WHEN severity = 'medium' THEN 1 ELSE 0 END) as medium_count,
			SUM(CASE WHEN severity = 'low' THEN 1 ELSE 0 END) as low_count,
			SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_count,
			SUM(CASE WHEN status = 'resolved' THEN 1 ELSE 0 END) as resolved_count,
			SUM(CASE WHEN status = 'verified' THEN 1 ELSE 0 END) as verified_count,
			SUM(CASE WHEN false_positive = 1 THEN 1 ELSE 0 END) as false_positive_count,
			AVG(risk_score) as avg_risk_score
		FROM {$this->table_name} 
		{$where_clause}";

		if ( ! empty( $where_params ) ) {
			$sql = $this->wpdb->prepare( $sql, $where_params );
		}

		$result = $this->wpdb->get_row( $sql );

		return array(
			'total_vulnerabilities' => intval( $result->total_vulnerabilities ),
			'severity_counts'       => array(
				'critical' => intval( $result->critical_count ),
				'high'     => intval( $result->high_count ),
				'medium'   => intval( $result->medium_count ),
				'low'      => intval( $result->low_count ),
			),
			'status_counts'         => array(
				'active'   => intval( $result->active_count ),
				'resolved' => intval( $result->resolved_count ),
				'verified' => intval( $result->verified_count ),
			),
			'false_positive_count'  => intval( $result->false_positive_count ),
			'avg_risk_score'        => floatval( $result->avg_risk_score ),
		);
	}

	/**
	 * Get vulnerability trends.
	 *
	 * @since    1.0.0
	 * @param    string   $period       Time period (daily, weekly, monthly).
	 * @param    int      $limit        Number of periods to retrieve.
	 * @return   array    Trend data.
	 */
	public function get_vulnerability_trends( $period = 'daily', $limit = 30 ) {
		$date_format = '%Y-%m-%d';
		$interval = '1 DAY';

		switch ( $period ) {
			case 'weekly':
				$date_format = '%Y-%u';
				$interval = '1 WEEK';
				break;
			case 'monthly':
				$date_format = '%Y-%m';
				$interval = '1 MONTH';
				break;
		}

		$sql = "SELECT 
			DATE_FORMAT(detected_at, '{$date_format}') as period,
			COUNT(*) as total_count,
			SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical_count,
			SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high_count,
			SUM(CASE WHEN severity = 'medium' THEN 1 ELSE 0 END) as medium_count,
			SUM(CASE WHEN severity = 'low' THEN 1 ELSE 0 END) as low_count
		FROM {$this->table_name}
		WHERE detected_at >= DATE_SUB(NOW(), INTERVAL %d {$interval})
		AND false_positive = 0
		GROUP BY period
		ORDER BY period DESC
		LIMIT %d";

		return $this->wpdb->get_results( $this->wpdb->prepare( $sql, $limit, $limit ) );
	}

	/**
	 * Get vulnerabilities by file path.
	 *
	 * @since    1.0.0
	 * @param    string   $file_path    The file path.
	 * @param    array    $args         Additional query arguments.
	 * @return   array    Array of vulnerability objects.
	 */
	public function get_vulnerabilities_by_file( $file_path, $args = array() ) {
		$args['where'] = array( 'file_path' => $file_path );
		return $this->get_all( $args );
	}

	/**
	 * Get top vulnerable files.
	 *
	 * @since    1.0.0
	 * @param    int    $limit    Number of files to retrieve.
	 * @return   array  Array of file vulnerability data.
	 */
	public function get_top_vulnerable_files( $limit = 10 ) {
		$sql = "SELECT 
			file_path,
			COUNT(*) as vulnerability_count,
			SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical_count,
			SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high_count,
			AVG(risk_score) as avg_risk_score
		FROM {$this->table_name}
		WHERE status = 'active' 
		AND false_positive = 0
		AND file_path IS NOT NULL 
		AND file_path != ''
		GROUP BY file_path
		ORDER BY vulnerability_count DESC, avg_risk_score DESC
		LIMIT %d";

		return $this->wpdb->get_results( $this->wpdb->prepare( $sql, $limit ) );
	}

	/**
	 * Get duplicate vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    string   $vulnerability_hash    The vulnerability hash.
	 * @param    int      $exclude_scan_id       Scan ID to exclude.
	 * @return   array    Array of duplicate vulnerability objects.
	 */
	public function get_duplicate_vulnerabilities( $vulnerability_hash, $exclude_scan_id = null ) {
		$where = array( 'vulnerability_hash' => $vulnerability_hash );
		
		if ( $exclude_scan_id ) {
			$where_clause = 'vulnerability_hash = %s AND scan_id != %d';
			$results = $this->wpdb->get_results( $this->wpdb->prepare(
				"SELECT * FROM {$this->table_name} WHERE {$where_clause}",
				$vulnerability_hash,
				$exclude_scan_id
			) );
		} else {
			$results = $this->get_all( array( 'where' => $where ) );
		}

		return $results;
	}

	/**
	 * Bulk update vulnerability status.
	 *
	 * @since    1.0.0
	 * @param    array    $vulnerability_ids    Array of vulnerability IDs.
	 * @param    string   $status               New status.
	 * @param    array    $additional_data      Additional data to update.
	 * @return   int      Number of vulnerabilities updated.
	 */
	public function bulk_update_status( $vulnerability_ids, $status, $additional_data = array() ) {
		if ( empty( $vulnerability_ids ) ) {
			return 0;
		}

		$ids_placeholder = implode( ',', array_fill( 0, count( $vulnerability_ids ), '%d' ) );
		$update_data = array_merge( $additional_data, array( 'status' => $status ) );

		// Set timestamps based on status
		if ( $status === 'resolved' ) {
			$update_data['resolved_at'] = current_time( 'mysql' );
		} elseif ( $status === 'verified' ) {
			$update_data['verified_at'] = current_time( 'mysql' );
		}

		$set_clause = array();
		$values = array();

		foreach ( $update_data as $column => $value ) {
			$set_clause[] = "{$column} = %s";
			$values[] = $value;
		}

		$sql = "UPDATE {$this->table_name} 
		        SET " . implode( ', ', $set_clause ) . "
		        WHERE id IN ({$ids_placeholder})";

		$values = array_merge( $values, $vulnerability_ids );

		return $this->wpdb->query( $this->wpdb->prepare( $sql, $values ) );
	}

	/**
	 * Delete old resolved vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    int    $days_old    Number of days to keep.
	 * @return   int    Number of vulnerabilities deleted.
	 */
	public function delete_old_resolved( $days_old = 180 ) {
		$cutoff_date = date( 'Y-m-d H:i:s', strtotime( "-{$days_old} days" ) );

		$result = $this->wpdb->query( $this->wpdb->prepare(
			"DELETE FROM {$this->table_name} 
			WHERE status = 'resolved' 
			AND resolved_at < %s",
			$cutoff_date
		) );

		return intval( $result );
	}

	/**
	 * Calculate risk score for a vulnerability.
	 *
	 * @since    1.0.0
	 * @param    array    $data    The vulnerability data.
	 * @return   float    The calculated risk score.
	 */
	private function calculate_risk_score( $data ) {
		$base_scores = array(
			'critical' => 9.0,
			'high'     => 7.0,
			'medium'   => 5.0,
			'low'      => 3.0,
		);

		$severity = $data['severity'] ?? 'low';
		$base_score = $base_scores[ $severity ] ?? 3.0;

		// Adjust score based on vulnerability type
		$type_modifiers = array(
			'sql_injection'     => 1.2,
			'xss'               => 1.1,
			'csrf'              => 1.0,
			'file_inclusion'    => 1.3,
			'command_injection' => 1.4,
			'authentication'    => 1.1,
			'authorization'     => 1.0,
			'information_disclosure' => 0.9,
		);

		$type = $data['vulnerability_type'] ?? '';
		$modifier = $type_modifiers[ $type ] ?? 1.0;

		return min( 10.0, $base_score * $modifier );
	}

	/**
	 * Generate a unique hash for the vulnerability.
	 *
	 * @since    1.0.0
	 * @param    array    $data    The vulnerability data.
	 * @return   string   The generated hash.
	 */
	private function generate_vulnerability_hash( $data ) {
		$hash_data = array(
			'type'        => $data['vulnerability_type'],
			'title'       => $data['title'],
			'file_path'   => $data['file_path'] ?? '',
			'line_number' => $data['line_number'] ?? 0,
		);

		return hash( 'sha256', wp_json_encode( $hash_data ) );
	}

	/**
	 * Get vulnerabilities requiring attention.
	 *
	 * @since    1.0.0
	 * @param    int    $limit    Number of vulnerabilities to retrieve.
	 * @return   array  Array of vulnerability objects that need attention.
	 */
	public function get_vulnerabilities_requiring_attention( $limit = 20 ) {
		$sql = "SELECT * FROM {$this->table_name}
		        WHERE status = 'active' 
		        AND false_positive = 0
		        AND (severity IN ('critical', 'high') 
		             OR detected_at < DATE_SUB(NOW(), INTERVAL 7 DAY))
		        ORDER BY 
		            CASE severity 
		                WHEN 'critical' THEN 1 
		                WHEN 'high' THEN 2 
		                WHEN 'medium' THEN 3 
		                ELSE 4 
		            END,
		            detected_at ASC
		        LIMIT %d";

		return $this->wpdb->get_results( $this->wpdb->prepare( $sql, $limit ) );
	}

	/**
	 * Get vulnerability count with optional filters.
	 *
	 * @since    1.0.0
	 * @param    array    $filters    Optional filters for the count.
	 * @return   int    The vulnerability count.
	 */
	public function get_vulnerability_count( $filters = array() ) {
		$where_clause = '1=1';
		$where_values = array();

		if ( ! empty( $filters['status'] ) ) {
			$where_clause .= ' AND status = %s';
			$where_values[] = $filters['status'];
		}

		if ( ! empty( $filters['severity'] ) ) {
			$where_clause .= ' AND severity = %s';
			$where_values[] = $filters['severity'];
		}

		if ( ! empty( $filters['type'] ) ) {
			$where_clause .= ' AND vulnerability_type = %s';
			$where_values[] = $filters['type'];
		}

		if ( ! empty( $filters['scan_id'] ) ) {
			$where_clause .= ' AND scan_id = %d';
			$where_values[] = $filters['scan_id'];
		}

		$sql = "SELECT COUNT(*) FROM {$this->table_name} WHERE {$where_clause}";

		if ( ! empty( $where_values ) ) {
			return (int) $this->wpdb->get_var( $this->wpdb->prepare( $sql, $where_values ) );
		}

		return (int) $this->wpdb->get_var( $sql );
	}

	/**
	 * Get vulnerability counts grouped by severity.
	 *
	 * @since    1.0.0
	 * @param    array    $filters    Optional filters.
	 * @return   array    Severity counts.
	 */
	public function get_vulnerability_counts_by_severity( $filters = array() ) {
		$where_clause = '1=1';
		$where_values = array();

		if ( ! empty( $filters['status'] ) ) {
			$where_clause .= ' AND status = %s';
			$where_values[] = $filters['status'];
		}

		if ( ! empty( $filters['scan_id'] ) ) {
			$where_clause .= ' AND scan_id = %d';
			$where_values[] = $filters['scan_id'];
		}

		$sql = "SELECT severity, COUNT(*) as count FROM {$this->table_name} WHERE {$where_clause} GROUP BY severity";

		if ( ! empty( $where_values ) ) {
			$results = $this->wpdb->get_results( $this->wpdb->prepare( $sql, $where_values ) );
		} else {
			$results = $this->wpdb->get_results( $sql );
		}

		$counts = array(
			'critical' => 0,
			'high'     => 0,
			'medium'   => 0,
			'low'      => 0,
		);

		foreach ( $results as $result ) {
			$counts[ $result->severity ] = (int) $result->count;
		}

		return $counts;
	}

	/**
	 * Get vulnerability counts grouped by status.
	 *
	 * @since    1.0.0
	 * @param    array    $filters    Optional filters.
	 * @return   array    Status counts.
	 */
	public function get_vulnerability_counts_by_status( $filters = array() ) {
		$where_clause = '1=1';
		$where_values = array();

		if ( ! empty( $filters['severity'] ) ) {
			$where_clause .= ' AND severity = %s';
			$where_values[] = $filters['severity'];
		}

		if ( ! empty( $filters['scan_id'] ) ) {
			$where_clause .= ' AND scan_id = %d';
			$where_values[] = $filters['scan_id'];
		}

		$sql = "SELECT status, COUNT(*) as count FROM {$this->table_name} WHERE {$where_clause} GROUP BY status";

		if ( ! empty( $where_values ) ) {
			$results = $this->wpdb->get_results( $this->wpdb->prepare( $sql, $where_values ) );
		} else {
			$results = $this->wpdb->get_results( $sql );
		}

		$counts = array(
			'active'    => 0,
			'resolved'  => 0,
			'dismissed' => 0,
		);

		foreach ( $results as $result ) {
			$counts[ $result->status ] = (int) $result->count;
		}

		return $counts;
	}

	/**
	 * Get vulnerability counts grouped by type.
	 *
	 * @since    1.0.0
	 * @param    array    $filters    Optional filters.
	 * @return   array    Type counts.
	 */
	public function get_vulnerability_counts_by_type( $filters = array() ) {
		$where_clause = '1=1';
		$where_values = array();

		if ( ! empty( $filters['status'] ) ) {
			$where_clause .= ' AND status = %s';
			$where_values[] = $filters['status'];
		}

		if ( ! empty( $filters['severity'] ) ) {
			$where_clause .= ' AND severity = %s';
			$where_values[] = $filters['severity'];
		}

		$sql = "SELECT vulnerability_type, COUNT(*) as count FROM {$this->table_name} WHERE {$where_clause} GROUP BY vulnerability_type";

		if ( ! empty( $where_values ) ) {
			$results = $this->wpdb->get_results( $this->wpdb->prepare( $sql, $where_values ) );
		} else {
			$results = $this->wpdb->get_results( $sql );
		}

		$counts = array();
		foreach ( $results as $result ) {
			$counts[ $result->vulnerability_type ] = (int) $result->count;
		}

		return $counts;
	}

	/**
	 * Get vulnerabilities with optional filters.
	 *
	 * @since    1.0.0
	 * @param    array    $filters    Optional filters.
	 * @return   array    Vulnerabilities.
	 */
	public function get_vulnerabilities( $filters = array() ) {
		$args = array();
		
		if ( ! empty( $filters ) ) {
			$args['where'] = array();
			
			if ( isset( $filters['status'] ) ) {
				$args['where']['status'] = $filters['status'];
			}
			
			if ( isset( $filters['severity'] ) ) {
				$args['where']['severity'] = $filters['severity'];
			}
			
			if ( isset( $filters['type'] ) ) {
				$args['where']['vulnerability_type'] = $filters['type'];
			}
			
			if ( isset( $filters['limit'] ) ) {
				$args['limit'] = intval( $filters['limit'] );
			}
			
			if ( isset( $filters['offset'] ) ) {
				$args['offset'] = intval( $filters['offset'] );
			}
		}
		
		return $this->get_all( $args );
	}

	/**
	 * Get fixable vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    array    $args    Optional arguments.
	 * @return   array    Fixable vulnerabilities.
	 */
	public function get_fixable_vulnerabilities( $args = array() ) {
		$default_args = array(
			'where' => array(
				'status' => 'active',
				'false_positive' => 0,
			),
			'order_by' => 'severity',
			'order' => 'DESC',
		);
		
		$args = wp_parse_args( $args, $default_args );
		
		// Only include vulnerabilities that have automated fixes available
		$fixable_types = array(
			'outdated_plugin',
			'outdated_theme',
			'weak_passwords',
			'file_permissions',
			'directory_listing',
		);
		
		if ( ! isset( $args['where']['vulnerability_type'] ) ) {
			$args['where']['vulnerability_type'] = $fixable_types;
		}
		
		return $this->get_all( $args );
	}

	/**
	 * Get resolved vulnerabilities count.
	 *
	 * @since    1.0.0
	 * @param    array    $filters    Optional filters.
	 * @return   int      Count of resolved vulnerabilities.
	 */
	public function get_resolved_count( $filters = array() ) {
		$base_filters = array( 'status' => 'resolved' );
		
		if ( ! empty( $filters ) ) {
			$base_filters = array_merge( $base_filters, $filters );
		}
		
		return $this->get_vulnerability_count( $base_filters );
	}

	/**
	 * Get recent vulnerabilities.
	 *
	 * @since    1.0.0
	 * @param    array    $args    Arguments for query.
	 * @return   array    Array of recent vulnerabilities.
	 */
	public function get_recent_vulnerabilities( $args = array() ) {
		$defaults = array(
			'limit'    => 10,
			'order_by' => 'detected_at',
			'order'    => 'DESC',
		);
		
		$args = wp_parse_args( $args, $defaults );
		
		return $this->get_all( $args );
	}

	/**
	 * Get alert statistics for dashboard.
	 *
	 * @since    1.0.0
	 * @return   array    Alert statistics.
	 */
	public function get_alert_statistics() {
		$current_time = current_time( 'mysql' );
		$today_start = date( 'Y-m-d 00:00:00', strtotime( $current_time ) );
		$week_start = date( 'Y-m-d 00:00:00', strtotime( '-7 days', strtotime( $current_time ) ) );

		// Get alerts today (critical and high severity only)
		$today_count = $this->wpdb->get_var(
			$this->wpdb->prepare(
				"SELECT COUNT(*) FROM {$this->table_name} 
				 WHERE detected_at >= %s AND severity IN ('critical', 'high')",
				$today_start
			)
		);

		// Get alerts this week
		$week_count = $this->wpdb->get_var(
			$this->wpdb->prepare(
				"SELECT COUNT(*) FROM {$this->table_name} 
				 WHERE detected_at >= %s AND severity IN ('critical', 'high')",
				$week_start
			)
		);

		// Calculate resolution rate
		$total_alerts = $this->wpdb->get_var(
			"SELECT COUNT(*) FROM {$this->table_name} 
			 WHERE severity IN ('critical', 'high')"
		);

		$resolved_alerts = $this->wpdb->get_var(
			"SELECT COUNT(*) FROM {$this->table_name} 
			 WHERE severity IN ('critical', 'high') AND status IN ('fixed', 'ignored')"
		);

		$resolution_rate = $total_alerts > 0 ? ( $resolved_alerts / $total_alerts ) * 100 : 0;

		// Calculate average response time (simplified - time from detection to status change)
		$response_times = $this->wpdb->get_col(
			"SELECT TIMESTAMPDIFF(SECOND, detected_at, updated_at) 
			 FROM {$this->table_name} 
			 WHERE severity IN ('critical', 'high') 
			 AND status IN ('fixed', 'ignored', 'in_progress') 
			 AND updated_at > detected_at 
			 ORDER BY updated_at DESC 
			 LIMIT 50"
		);

		$avg_response_time = ! empty( $response_times ) ? array_sum( $response_times ) / count( $response_times ) : 0;

		return array(
			'today'               => (int) $today_count,
			'week'                => (int) $week_count,
			'avg_response_time'   => (int) $avg_response_time,
			'resolution_rate'     => (float) $resolution_rate,
			'total_alerts'        => (int) $total_alerts,
			'resolved_alerts'     => (int) $resolved_alerts
		);
	}

	/**
	 * Get vulnerability distribution data for reporting.
	 *
	 * @since    1.0.0
	 * @return   array    Vulnerability distribution data.
	 */
	public function get_vulnerability_distribution() {
		// Get distribution by component type
		$component_distribution = $this->wpdb->get_results(
			"SELECT 
				component_type,
				COUNT(*) as count,
				ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM {$this->table_name}), 1) as percentage
			FROM {$this->table_name} 
			GROUP BY component_type 
			ORDER BY count DESC",
			ARRAY_A
		);

		// Get distribution by severity
		$severity_distribution = $this->wpdb->get_results(
			"SELECT 
				severity,
				COUNT(*) as count,
				ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM {$this->table_name}), 1) as percentage
			FROM {$this->table_name} 
			GROUP BY severity 
			ORDER BY FIELD(severity, 'critical', 'high', 'medium', 'low')",
			ARRAY_A
		);

		// Get distribution by vulnerability type
		$type_distribution = $this->wpdb->get_results(
			"SELECT 
				vulnerability_type,
				COUNT(*) as count,
				ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM {$this->table_name}), 1) as percentage
			FROM {$this->table_name} 
			GROUP BY vulnerability_type 
			ORDER BY count DESC 
			LIMIT 10",
			ARRAY_A
		);

		// Get monthly trend
		$monthly_trend = $this->wpdb->get_results(
			"SELECT 
				DATE_FORMAT(detected_at, '%Y-%m') as month,
				COUNT(*) as count
			FROM {$this->table_name} 
			WHERE detected_at >= DATE_SUB(NOW(), INTERVAL 12 MONTH)
			GROUP BY DATE_FORMAT(detected_at, '%Y-%m') 
			ORDER BY month ASC",
			ARRAY_A
		);

		return array(
			'by_component' => $component_distribution,
			'by_severity'  => $severity_distribution,
			'by_type'      => $type_distribution,
			'monthly_trend' => $monthly_trend,
			'total_count'  => $this->wpdb->get_var( "SELECT COUNT(*) FROM {$this->table_name}" )
		);
	}
}
